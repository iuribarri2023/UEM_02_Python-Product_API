{\rtf1\ansi\deff0
{\fonttbl{\f0\fswiss Helvetica;}}
\f0\fs24
1. Introduccion y objetivos del trabajo\line
Este documento describe de forma ordenada y entendible el funcionamiento de una pequena API desarrollada en Flask que gestiona productos y pedidos para una tienda en linea. El objetivo es explicar como esta organizado el proyecto, que tecnologias se utilizan, como se almacenan los datos en estructuras de datos (BST para productos y lista enlazada para pedidos) y como se puede probar la API mediante Swagger/OpenAPI.\line
\line
2. Arquitectura del proyecto\line
El proyecto separa la logica principal, configuracion, estructuras de datos, repositorios y esquemas de validacion.\line
\line
2.1 Estructura de carpetas\line
Los archivos y directorios principales son:\line
• main.py: punto de entrada; crea la aplicacion Flask con create_app y la arranca.\line
• app/__init__.py: factoria de la app; carga configuracion, inicializa Flask-Smorest, registra el blueprint de pedidos/productos y define rutas basicas "/" y "/health".\line
• app/config.py: configuracion general y metadatos OpenAPI.\line
• app/extensions.py: instancia Api de Flask-Smorest.\line
• app/api/orders.py: endpoints REST para productos y pedidos.\line
• app/services/data_structures.py: implementacion del arbol binario de busqueda y la lista enlazada.\line
• app/services/order_service.py: logica de negocio de pedidos (resolucion de items, totales).\line
• app/repositories/product_repository.py: acceso a datos de productos en JSON usando BST en memoria.\line
• app/repositories/order_repository.py: acceso a datos de pedidos en JSON usando lista enlazada en memoria.\line
• app/schemas/: esquemas Marshmallow para validar entradas y salidas de productos y pedidos.\line
• data/products.json y data/orders.json: archivos JSON que actuan como base de datos simulada.\line
\line
2.2 Dependencias principales\line
Las dependencias clave (requirements.txt) incluyen:\line
• Flask: framework principal para la API.\line
• Flask-Smorest: blueprints, validacion y documentacion OpenAPI automatica.\line
• Marshmallow: esquemas y validacion de datos.\line
• requests: no se usa en el flujo actual, pero permanece disponible.\line
• python-dotenv: carga de variables de entorno en desarrollo.\line
\line
3. Estructuras de datos: BST y lista enlazada\line
La API usa estructuras explicitas para cumplir los requisitos de eficiencia y modelado.\line
\line
3.1 Productos en arbol binario de busqueda (BST)\line
• En product_repository se mantiene un BinarySearchTree en memoria.\line
• Cada nodo almacena un producto identificado por su id.\line
• Las operaciones de lectura (GET) usan tree.find y tree.inorder; las inserciones (POST) usan tree.insert.\line
• La persistencia se realiza guardando el recorrido in-order en data/products.json, garantizando consistencia entre el BST y el JSON.\line
\line
3.2 Pedidos en lista enlazada\line
• En order_repository se mantiene un OrderLinkedList en memoria.\line
• Cada nodo representa un pedido completo con varios productos (items con product_id, cantidad y metadatos del producto).\line
• Las operaciones GET/POST/PATCH/DELETE recorren y modifican la lista (find, append, update, delete).\line
• Las mutaciones se persisten exportando la lista a data/orders.json mediante to_list().\line
\line
4. Exposicion de la informacion API (Flask + Flask-Smorest)\line
La API se organiza en un unico blueprint (app/api/orders.py) que agrupa productos y pedidos. Flask-Smorest genera la documentacion OpenAPI y Swagger UI.\line
\line
Endpoints principales:\line
• Productos:\line
  - GET /v1/products: lista productos (recorrido in-order del BST).\line
  - GET /v1/products/{id}: obtiene producto por ID desde el BST.\line
  - POST /v1/products: crea producto (name, price, stock, description).\line
• Pedidos:\line
  - GET /v1/orders: lista pedidos (recorrido de la lista enlazada).\line
  - GET /v1/orders/{id}: obtiene pedido por ID.\line
  - POST /v1/orders: crea pedido con items [{ product_id, quantity }]; resuelve productos, calcula totales y almacena el pedido en la lista enlazada.\line
  - PATCH /v1/orders/{id}: actualiza cliente o items recalculando el total.\line
  - DELETE /v1/orders/{id}: elimina un pedido de la lista enlazada.\line
\line
5. Gestion de datos y almacenamiento\line
Se usa un archivo JSON para cada entidad como base de datos simulada.\line
• data/products.json: inicializado con productos de construccion (cemento, arena, ladrillos, vigas, yeso).\line
• data/orders.json: inicializado con pedidos de ejemplo que referencian esos productos; cada elemento es un nodo de la lista enlazada al cargarse.\line
• Los repositorios leen los JSON al iniciar y mantienen las estructuras (BST/lista) en memoria; cualquier cambio se persiste nuevamente al archivo correspondiente.\line
\line
6. Documentacion y pruebas con Swagger / OpenAPI\line
• El esquema OpenAPI se publica en /openapi.json.\line
• Swagger UI esta disponible en /docs.\line
• Los esquemas Marshmallow alimentan la documentacion (paths, parametros, cuerpos y respuestas).\line
• Rutas de utilidad: "/" (landing con enlaces a docs y health) y "/health" (estado basico).\line
\line
7. Pasos para ejecutar el proyecto en local\line
• Instalar dependencias: pip install -r requirements.txt.\line
• Lanzar la aplicacion: python main.py.\line
• Probar en navegador: http://localhost:5000/docs para Swagger, y las rutas /v1/products y /v1/orders.\line
\line
8. Limitaciones, riesgos y posibles mejoras\line
Limitaciones actuales:\line
• Uso de archivos JSON: sencillo para aprender, pero no soporta concurrencia ni grandes volumenes.\line
• La logica de negocio asume que los productos existen al crear pedidos; no hay control de stock ni transacciones.\line
Posibles mejoras futuras:\line
• Sustituir JSON por una base de datos real con migraciones.\line
• Añadir pruebas automáticas y validaciones adicionales (por ejemplo, stock disponible).\line
• Incorporar autenticacion/autorizacion para consumidores de la API.\line
• Mejorar logs y manejo de errores.\line
\line
9. Conclusion\line
Esta API demuestra como un proyecto pequeno en Flask puede combinar estructuras de datos (BST y lista enlazada), validacion con Marshmallow, documentacion automatica con OpenAPI y persistencia simple en JSON. La arquitectura por servicios, repositorios, blueprints y esquemas facilita extender el proyecto hacia escenarios mas robustos.\line
}
